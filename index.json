[{"authors":null,"categories":null,"content":"Interprocess Communication with WebSockets A socket is an endpoint of an inter-process communication flow. A socket is bound to a port in a computer and enables communication over a communication protocol (e.g. UDP and TCP). When a socket is bound to the TCP protocol it allows bi-directional communication between two processes.\nWebSocket is a new technology (HTML5) inspired in classic sockets. WebSocket provides full-duplex communication over browser and servers, but it can be used by any client or server application (e.g. mobile applications). In this exercise you will experiment with sockets by developing a chat application using WebSockets.\nRequirements   Chat Application  NodeJS  Express  SocketIO  Objectives Experiment with the development of sockets.\nChat Application The chat application is composed of the following files:\n js \u0026mdash; contains the chat console client html \u0026mdash; contains the chat web client js \u0026mdash; contains the code of the server json \u0026mdash; contains the build dependencies  Application dependencies can be installed by executing the following command in the folder containing the application files:\nnpm install  Client and server are executed by issuing the following commands:\nnode Client.js node Server.js  Once the server is running, open a browser and go to http://localhost:8080.\nTo Do Hand in a short report explaining what you did and what you learned and a zip with your application to javier.espino**@imag.fr.\n Broadcast a message to connected users when someone connects or disconnects. Add support for nicknames. Show who\u0026rsquo;s online. Add private messaging. Model the application using the object oriented model and describe its architecture.  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"21f18a3466189de39a8521f096772ad0","permalink":"https://javieraespinosa.github.io/web-programming-and-services/tp1/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/web-programming-and-services/tp1/","section":"","summary":"Interprocess Communication with WebSockets A socket is an endpoint of an inter-process communication flow. A socket is bound to a port in a computer and enables communication over a communication protocol (e.g. UDP and TCP). When a socket is bound to the TCP protocol it allows bi-directional communication between two processes.\nWebSocket is a new technology (HTML5) inspired in classic sockets. WebSocket provides full-duplex communication over browser and servers, but it can be used by any client or server application (e.","tags":null,"title":"","type":"page"},{"authors":null,"categories":null,"content":"Remote Method Invocation (RMI) The remote procedure call (RPC) approach extends the common programming abstraction of the procedure call to distributed environments, allowing a calling process to call a procedure in a remote node as if it is local.\nRemote method invocation (RMI) is similar to RPC but for distributed objects, with added benefits in terms of using object-oriented programming concepts in distributed systems. It also extends the concept of an object reference to the global distributed environments, and allows the use of object references as parameters in remote invocations.\nIn this exercise you will experiment with RMI by developing an object oriented chat application using Java RMI.\nRequirements   Java SDK  Chat Application  Objectives  Experiment with the development of RMI. Compare Socket and RMI development.  Chat Application The chat application is composed of the following files:\n IChatServer.java \u0026mdash; lists the (remote) operations exposed by the Chat Server. ChatServer.java \u0026mdash; implements the Chat Server. IChatClient.java \u0026mdash; lists the (remote) operations exposed by the Chat Client. ChatClient.java \u0026mdash; implements the Chat Client. Run.java \u0026mdash; isolate the code initializing the chat\u0026rsquo; client and server parts. security.policy \u0026mdash; authorizes remote communication (in/out) in the JVM. StartServer.sh and StartClient.sh \u0026mdash; shell scripts for launching the Chat server and client.  The figure below illustrates the operations exposed by the client and server:\n Server  addClient(client) \u0026mdash; subscribes a new client into the chat server. send(msg) \u0026mdash; receives the message that will be broadcasted to all the clients connected (subscribed) to the server   Client  Notify(msg) \u0026mdash; receives a server notification (e.g., the string representing the message sent by a user)    The following code snippets show the Server and Client interfaces:\npublic interface IChatServer extends Remote { public void send(String msg) throws RemoteException; public void addClient(IChatClient client) throws RemoteException; } public interface IChatClient extends Remote { public void notify(String msg) throws RemoteException; }  Note that the figure also illustrates the process of a client subscription:\n A client instance contact call the addClient server operation and subscribe itself into the server. The server uses its send operation for notifying all connected clients about the connection of a new client.  You can start the chat\u0026rsquo; server and client parts by issuing the following commands:\njava -Djava.security.policy=file:security.policy # Run server java -Djava.security.policy=file:security.policy # Run client  Remark that these commands are abstracted in the scripts StartServer.sh and StartClient.sh.\nTo Do Hand in a short report explaining what you did and what you learned and a zip with your application. In particular describe the differences between developing a chat application using WebSockets and RMI and argue about the pertinence of using these tools for given applications.\n Broadcast a message to connected users when someone connects or disconnects. Add support for nicknames. Show who is online. Add private messaging.  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"04dfbcc6ad7b70ff3d9ce1f3fd0c719c","permalink":"https://javieraespinosa.github.io/web-programming-and-services/tp2/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/web-programming-and-services/tp2/","section":"","summary":"Remote Method Invocation (RMI) The remote procedure call (RPC) approach extends the common programming abstraction of the procedure call to distributed environments, allowing a calling process to call a procedure in a remote node as if it is local.\nRemote method invocation (RMI) is similar to RPC but for distributed objects, with added benefits in terms of using object-oriented programming concepts in distributed systems. It also extends the concept of an object reference to the global distributed environments, and allows the use of object references as parameters in remote invocations.","tags":null,"title":"","type":"page"},{"authors":null,"categories":null,"content":"CouchDB: A first touch This practical exercise is intended to make you reason about the differences of principles between \u0026ldquo;classic\u0026rdquo; RDBMS and NoSQL servers for building and managing data. DO NOT expect to acquire an extensive practice of the use of the DBMS used here. Rather expect to be able to:\n Point out some of their principles concerning: data model, design process, internal and external data management, architecture; Compare these principles with those of classic RDBMS.  Therefore we propose an exercise organized into two parts where you are supposed to run some tests and answer control questions for making sure that you are achieving the expected objective of the exercise.\nRequirements   CouchDB  cURL ( cURL 4 Windows)  Building and Querying a NoSQL Oriented Database In this exercise you will populate and query a NoSQL database using data coming from the Deezer RESTful service. In particular, you will use data related with the rock band Muse. For instance, the following links give access to Muse\u0026rsquo;s albums and information about similar artists (note that Muse has the ID 705 in Deezer):\n http://api.deezer.com/artist/705/albums http://api.deezer.com/artist/705/related  TO DO Creating and populating a database  Using a terminal, **create **the **database **Deezer:  curl -X PUT http://localhost:5984/deezer   Download (and save into files) the data about **Muse\u0026rsquo; album **and similar artists:  curl -X GET http://api.deezer.com/artist/705/albums \u0026gt; MuseAlbums.json curl -X GET http://api.deezer.com/artist/705/related \u0026gt; MuseRelatedAlbums.json   Populate the Deezer **database **with the retrieved information by issuing the following commands:  curl -X PUT http://localhost:5984/deezer/muse_albums --upload-file \u0026quot;MuseAlbums.json\u0026quot; curl -X PUT http://localhost:5984/deezer/muse_related_artists --upload-file \u0026quot;MuseRelatedAlbums.json\u0026quot;   Verify the content of the database:  curl -v http://localhost:5984/deezer/muse_albums curl -v http://localhost:5984/deezer/muse_related_artists  Note that the output includes the HTTP request (and reply) headers sent to (by) CouchDB.\n  Open Fouton (CouchDB Web Interface) on your browser: http://127.0.0.1:5984/_utils/index.html\n  Access and observe the database Deezer on Fouton.\n  Querying a database Execute the following queries:\n Query 1. Retrieve the name and the web page of the groups that are similar to the rock band Muse.  **Map** function(doc) { var artists = doc.data;\u2028if(doc._id == \u0026quot;muse_related_artists\u0026quot;) { for(var i in artists) emit(artists[i].name, artists[i].link); } }   Query 2. Compute the total number of the albums produced by the rock band Muse (requires to check the ***reduce check button ***in Fouton).  **Map** function(doc) { var artists = doc.data;\u2028if(doc._id == \u0026quot;muse_related_artists\u0026quot;) { for(var i in artists) emit('muse_albums', 1); } } **Reduce** function(keys, values, rereduce) { return sum(values); }  Theoretic questions (TO ANSWER)  Is it possible to represent data under the classic relational model (see the 1 Normal Form)? Compare the notion of key in a relational schema with respect to the notion of key in key-value NoSQL approaches. Why is it necessary to define views for querying a database in CouchDB? Is this a way of integrating data? Justify.  REFERENCES  Book CouchDB, the definitive guide  NoSQL  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"069ec57ba8aa3463cf00387155d32ae6","permalink":"https://javieraespinosa.github.io/web-programming-and-services/tp3a/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/web-programming-and-services/tp3a/","section":"","summary":"CouchDB: A first touch This practical exercise is intended to make you reason about the differences of principles between \u0026ldquo;classic\u0026rdquo; RDBMS and NoSQL servers for building and managing data. DO NOT expect to acquire an extensive practice of the use of the DBMS used here. Rather expect to be able to:\n Point out some of their principles concerning: data model, design process, internal and external data management, architecture; Compare these principles with those of classic RDBMS.","tags":null,"title":"","type":"page"},{"authors":null,"categories":null,"content":"CouchDB: Expressing queries Requirement   CouchDB  cURL  AlloCine files  To Hand In This exercise will be handed in electronically:\n You will form groups of 2 or three A report with answers and explanations of the principle you adopted in PDF The report will state the JavaScript answers to the questions.  To Do For this exercise you will use a set of file containing information about the films presented in Grenoble in 2011 (information retrieved from AlloCine API). Each of these files contains the films presented in a cinema of Grenoble at that time (i.e. there is a file per cinema and a total number of 9).\nStart by creating and populating a new database in CouchDB using the data contained in the files named allocineGrenobleN.txt with N from 1 to 9. For this purpose execute the following commands:\ncurl -X PUT http://localhost:5984/allocine curl -T \u0026quot;allocineGrenoble1.txt\u0026quot; http://localhost:5984/allocine/allocineGrenoble1 curl -T \u0026quot;allocineGrenoble2.txt\u0026quot; http://localhost:5984/allocine/allocineGrenoble2 curl -T \u0026quot;allocineGrenoble3.txt\u0026quot; http://localhost:5984/allocine/allocineGrenoble3 curl -T \u0026quot;allocineGrenoble4.txt\u0026quot; http://localhost:5984/allocine/allocineGrenoble4 curl -T \u0026quot;allocineGrenoble5.txt\u0026quot; http://localhost:5984/allocine/allocineGrenoble5 curl -T \u0026quot;allocineGrenoble6.txt\u0026quot; http://localhost:5984/allocine/allocineGrenoble6 curl -T \u0026quot;allocineGrenoble7.txt\u0026quot; http://localhost:5984/allocine/allocineGrenoble7 curl -T \u0026quot;allocineGrenoble8.txt\u0026quot; http://localhost:5984/allocine/allocineGrenoble8 curl -T \u0026quot;allocineGrenoble9.txt\u0026quot; http://localhost:5984/allocine/allocineGrenoble9  In your report give the code and a screen shot with the content on the database.\nUsing this database answer the following questions and do not forget to give:\n the code of the answer the screenshots with the content of the database  Feel free to use the CouchDB book for getting some inspiration.\nQuestion 1 Note that the data set is quite complete. Define a simplified view in MapReduce that contains for each theatre the films presented in it. Hint: You do not need a \u0026ldquo;reduce\u0026rdquo; here.\nQuestion 2 Modify your answer to question 1 for filtering the theatres outside Grenoble downtown (e.g., do not include the theatres in Saint Martin d\u0026rsquo;Hères).\nQuestion 3 Give the number of films that each theatre is presenting. Hint: You need a \u0026ldquo;reduce\u0026rdquo; here.\nQuestion 4 Give the list of films with a press rating higher than 4 stars. Attention: filter duplicates.\nQuestion 5 Give the list of films presented 2 years ago (10.12.2011), and for each film, the theatre where it was presented and its schedule.\nQuestion 7 (BONUS) Give the list of films and for every film the list of theatres that present it. This question is a challenge but we encourage you to try to solve it.\n Acknowledgment\nDr. Alexandre Termier, University Joseph Fourier originally designed this exercise. It has been slightly modified for this course.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"0db6c22b2359b6166dab1ced1743ba64","permalink":"https://javieraespinosa.github.io/web-programming-and-services/tp3b/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/web-programming-and-services/tp3b/","section":"","summary":"CouchDB: Expressing queries Requirement   CouchDB  cURL  AlloCine files  To Hand In This exercise will be handed in electronically:\n You will form groups of 2 or three A report with answers and explanations of the principle you adopted in PDF The report will state the JavaScript answers to the questions.  To Do For this exercise you will use a set of file containing information about the films presented in Grenoble in 2011 (information retrieved from AlloCine API).","tags":null,"title":"","type":"page"},{"authors":null,"categories":null,"content":"Developing a RESTful Service In Service Oriented Programming a RESTful service is a service conforming to the REST (Representational State Transfer) architecture style. In this kind of architecture (i) you think in terms of resources and their representations (instead of thinking about operations, inputs and outputs), and (ii) you address and transfer resource states using the URI and HTTP standards.\nWhen a service follows the REST architecture, every client knowing how to use HTTP can access the states and representations of the resources of a RESful service (cf. figure below). In this exercise you will develop a RESTful service using Javascript and NodeJS for exposing a music catalogue as a set of resources.\nRequirements   NodeJS  Express (NodeJS module)  cURL or Postman (Chrome extension)  CouchDB MusicCatalog app ( download)  Objectives  Implement a RESTful service and understand the use of HTTP methods for interacting with it. Develop an application that uses your RESTful service. Use a NoSQL database for storing the RESTful service data.  Music catalog overview For this exercise you will use the **Music Catalog **application. The following figure illustrates its architecture (REST service and client parts).\nAs shown in the figure, the Music Catalog service exposes two resources:\n /albums \u0026mdash; represents a music catalog as a collection of albums. /albums/:id \u0026mdash; represents an album identified by :id.  The figure also shows that clients and service exchange information about albums using the JSON data representation. The following diagram the structure representing an album instance.\nService behaviour In order to implement a RESTful service you have to specify what to do when a client executes an HTTP operation over one of your resources. In web programming this is called routing (i.e. the association of a HTTP operation with a resource).\nThe table below summarizes the semantic of HTTP operations when executed over the Music Catalog resources.\n   URL Method Parameter Description     http://localhost:3000/albums GET \u0026ndash; List all the albums   PUT \u0026ndash; Unused    POST \u0026ndash; Unused    DELETE \u0026ndash; Unused    http://localhost:3000/albums/:id GET \u0026ndash; Get the album   PUT Album Update the album    POST \u0026ndash; Unused    DELETE \u0026ndash; Delete the album     In the Music Catalog REST service, these semantics are implemented by the routings specified in the CatalogService.js file. The content of this file is shown below.\nvar express = require('express'); var bodyParser = require('body-parser'); var app = express(); app.use(bodyParser.json()); var albums = {}; albums['1'] = { \u0026quot;id\u0026quot;:1, \u0026quot;name\u0026quot;: 'The 2nd Law', \u0026quot;artist\u0026quot;: 'Muse', \u0026quot;year\u0026quot;: 2012 }; app.get('/albums', function (request, response) { response.json(albums); }); app.get('/albums/:id', function (request, response) { response.json(albums[request.params.id]); }); app.put('/albums/:id', function (request, response) { var album = request.body; albums[request.params.id] = album; response.json('OK'); }); app.delete('/albums/:id', function (request, response) { var deleted = delete albums[request.params.id]; response.json(deleted); }); var server = app.listen(3000, function () { console.log('Listening at http://localhost:%s', server.address().port); });  As you can see, the catalog service defines routes by calling the GET/PUT/POST/DELETE methods of an express object (see Express for more information). For instance, the following code snippet illustrates how to retrieve a specific album using its ID by routing the GET operation to the resource /albums/:id.\napp.get('/albums/:id', function (request, response) { response.json(albums[request.params.id]); });  Note that the ID of an album is resolved dynamically by matching the request\u0026rsquo; URI with the string /albums/:id. Also note that you can access this value at runtime by using the object request.params. Finally note that, before sending information back to the client (i.e., the set of albums), the service transforms the JavaScript object containing the album information (albums[request.params.id]) into its *JSON representation *(response.json(OBJECT)).\nThe following code snippet illustrates how to add a new album to the catalog by routing a PUT operation to the resource /albums/:id.\nvar app = express(); app.use(bodyParser.json()); app.put('/albums/:id', function (request, response) { var album = request.body; albums[request.params.id] = album; response.json('OK'); });  In this example the service retrieves the information about the new album by accessing the HTTP request body (request.body). Then, as in the previous example, it uses the *id *specified in the album resource (request.params.id) in order to store the album into the music catalog (albums[request.params.id] = album).\nRecall that client and service send albums\u0026rsquo; information using the JSON data representation. This implies that you have to ALWAYS transform a JavaScript object into JSON (and vice versa) in order to communicate. Note that in the previous example Express converts automatically the request.body to Javascript because it assumes that all body requests are represented in JSON (app.use(bodyParser.json())).\nTesting the service catalog Run the Music Catalog service by executing the following command inside the Music Catalog application folder:\nnode CatalogService  Once running, test the service by issuing the following HTTP requests with cURL (or Postman).\n # GET all albums curl localhost:3000/albums # Add new album curl -X PUT localhost:3000/albums/2 -H \u0026quot;Content-Type: application/json\u0026quot; -d @- { \u0026quot;id\u0026quot;: 2, \u0026quot;name\u0026quot;: \u0026quot;The Resistance\u0026quot;, \u0026quot;artist\u0026quot;: \u0026quot;Muse\u0026quot;, \u0026quot;year\u0026quot;: 2009 } # Press CTRL + D # GET all albums curl localhost:3000/albums  Service client Until now you have used a third-party tool for interacting with the Music Catalog service (e.g., Web Browser, cURL, Postman). In this section you will use the Catalog Client (a JavaScript application) for sending HTTP request to the Catalog Service.\nAs shown in the figure below, the Catalog Client is composed of the following classes:\n HttpClient \u0026mdash; Offers basic operations for executing HTTP requests. The HTTP client assumes that all data is sent using JSON as the data format representation. CatalogClient \u0026mdash; Offers operations for adding, getting, removing the albums in the Music Catalog. These operations use the HTTP Client. Run \u0026mdash; Script illustrating the use of the Catalog Client.   HTTP client The following snippet shows the code of the HTTP Client class (cf. HttpClient.js file).\nthis.GET = function(url, callback) { this.doRequest('GET', url, null, callback); }; this.PUT = function (url, data, callback) { this.doRequest('PUT', url, data, callback); }; this.DELETE = function (url, callback) { this.doRequest('DELETE', url, null, callback); }; this.doRequest = function(verb, url, data, callback) { var options = { hostname: URL.*parse*(url).hostname, port: URL.*parse*(url).port, path: URL.*parse*(url).path, method: verb, headers: { 'Content-Type': 'application/json', 'Content-Length': (data)? data.length: 0 } }; var req = http.request(options, function(res) {...); req.write( (data)? data: ''); req.end(); };  Note that all HTTPClient operations (GET/PUT/DELETE) depend on the doRequest function, which is in charge of preparing the HTTP message: *header *(options) and body (req.write(data)). Also note that doRequest assumes that all content (data) sent by the HTTPClient is represented in JSON (\u0026lsquo;Content-Type: application/json\u0026rsquo;).\nCatalog client The following snippet illustrates the use of the HttpClient for adding and *getting *an album (cf. CatalogClient.js).\nvar ALBUMS_URI = 'http://localhost:3000/albums'; var ALBUM_URI = 'http://localhost:3000/albums/{_}'; var http = new HttpClient(); this.addAlbum = function (album, callback) { var url = ALBUM_URI.replace('{_}', album.id); var data = JSON.stringify(album); http.PUT(url, data, callback) }; this.getAlbum = function (albumID, callback) { var url = ALBUM_URI.replace('{_}', albumID); http.GET(url, function (resp) { var album = JSON.parse(resp.body); callback(album); }); };  Note that before adding a new album into the catalog (using http.PUT), the addAlbum function converts the album JavaScript object into JSON using the JSON.stringify(). In a similar way, when the getAlbum function receives the response from the service, it uses the JSON.parsefunction for converting the response body (sent in JSON format) into a JavaScript object.\nRun script Finally the following code illustrates the use of the CatalogClient class for *adding, retrieving and removing *albums programmatically (cf. Run.js file).\n /// Step 0: Show the albums in the catalog .then(function (next) { client.getAlbums(function (albums) { console.log('\\n'+'ALBUMS (before insertion)'); console.log(albums); next(); }); }) /// Step 1: Insert new album in Catalog .then(function (next) { var album = { \u0026quot;id\u0026quot;:2, \u0026quot;name\u0026quot;:'The Resistance', \u0026quot;artist\u0026quot;:'Muse', \u0026quot;year\u0026quot;:2009 }; client.addAlbum(album, function (resp) { next(); }); }) /// Step 2: Insert another album (with errors) .then(function (next) { var album = { \u0026quot;id\u0026quot;: 3, \u0026quot;name\u0026quot;: 'XXXX', \u0026quot;artist\u0026quot;: 'YYYY', \u0026quot;year\u0026quot;: 0000 }; client.addAlbum(album, function (resp) { next(); }); }) /// Step 3: Show the albums in the catalog .then(function (next) { client.getAlbums(function (albums) { console.log('\\n'+'ALBUMS (after insertions)'); console.log(albums); next(); }); }) /// Step 4: Remove the album with errors .then(function (next) { client.removeAlbum('3', function () { next(); }); }) /// Step 5: Show (again) the albums in the catalog .then(function (next) { client.getAlbums(function (albums) { console.log('\\n'+'ALBUMS (after deletion)'); console.log(albums); next(); }); });  To Do For this exercise you have to:\n Describe the characteristics of the Catalog REST service. For instance, it is stateful/stateless, persistent/non-persistent? Implement a Deezer Client using the HTTPClient class for searching and retrieves information about albums using the Deezer RESTful Service. Modify the Catalog Service in order to store the Catalog in CouchDB. Define a CouchDB view for retrieving the URLs of the albums\u0026rsquo; covers (see CouchDB: The definitive guide).  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"af822400e36b5e141e8f8a33a28c253c","permalink":"https://javieraespinosa.github.io/web-programming-and-services/tp4/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/web-programming-and-services/tp4/","section":"","summary":"Developing a RESTful Service In Service Oriented Programming a RESTful service is a service conforming to the REST (Representational State Transfer) architecture style. In this kind of architecture (i) you think in terms of resources and their representations (instead of thinking about operations, inputs and outputs), and (ii) you address and transfer resource states using the URI and HTTP standards.\nWhen a service follows the REST architecture, every client knowing how to use HTTP can access the states and representations of the resources of a RESful service (cf.","tags":null,"title":"","type":"page"}]